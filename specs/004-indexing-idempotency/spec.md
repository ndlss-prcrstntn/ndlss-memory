# Спецификация фичи: Идемпотентность индексации

**Feature Branch**: `004-indexing-idempotency`
**Created**: 2026-02-21
**Status**: Draft
**Input**: User description: "Идемпотентность индексации: генерация hash контента (SHA256), проверка существования хеша перед upsert, использование deterministic ID для чанков, обновление записи при изменении файла, удаление устаревших чанков"

## User Scenarios & Testing *(mandatory)*

### User Story 1 - Стабильная идентификация контента (Priority: P1)

Как пользователь, я хочу, чтобы система стабильно определяла, изменился ли файл,
чтобы повторные запуски не создавали дубликаты и не выполняли лишнюю обработку.

**Why this priority**: Без надежной идентификации контента нельзя гарантировать
идемпотентность всего процесса индексации.

**Independent Test**: Запустить индексацию на неизмененном наборе файлов дважды и
проверить, что число уникальных записей не увеличилось.

**Acceptance Scenarios**:

1. **Given** файл уже был проиндексирован и его содержимое не менялось, **When**
   запускается повторная индексация, **Then** система распознает совпадение hash
   контента и пропускает повторную запись.
2. **Given** файл изменился, **When** запускается индексация, **Then** новый hash
   контента отличается от предыдущего и файл помечается как требующий обновления.

---

### User Story 2 - Детерминированное обновление чанков (Priority: P2)

Как пользователь, я хочу, чтобы чанки одного и того же файла имели стабильные
идентификаторы, чтобы изменения обновляли существующие записи, а не создавали
дубликаты.

**Why this priority**: Даже при корректном определении изменений ценность
идемпотентности теряется, если upsert не привязывается к стабильному идентификатору.

**Independent Test**: Выполнить индексацию файла, затем изменить часть содержимого
и повторить индексацию; проверить, что обновляются только затронутые чанки.

**Acceptance Scenarios**:

1. **Given** файл индексируется впервые, **When** формируются чанки, **Then** каждый
   чанк получает deterministic ID, повторяемый при том же входном содержимом.
2. **Given** изменена часть файла, **When** запускается повторная индексация,
   **Then** неизмененные чанки сохраняют идентификаторы, а измененные чанки
   обновляются как новые версии записей.

---

### User Story 3 - Очистка устаревших данных (Priority: P3)

Как пользователь, я хочу, чтобы устаревшие чанки удалялись из индекса после
изменения или удаления исходных данных, чтобы поиск работал только по актуальному
контенту.

**Why this priority**: Без удаления устаревших чанков индекс постепенно накапливает
неактуальные записи и ухудшает качество поиска.

**Independent Test**: Удалить файл или сократить его содержимое, выполнить
индексацию и проверить, что лишние чанки удалены из индекса.

**Acceptance Scenarios**:

1. **Given** файл удален из рабочей директории, **When** выполняется индексация,
   **Then** связанные чанки удаляются из векторного индекса.
2. **Given** количество чанков файла уменьшилось после редактирования, **When**
   завершается индексация, **Then** отсутствующие в новой версии чанки удаляются
   как устаревшие.

---

### Edge Cases

- Файл переименован без изменения содержимого.
- Файл содержит одинаковый контент, но изменены метаданные файловой системы.
- Файл одновременно очень большой и часто изменяется.
- Индексация прервалась между upsert и удалением устаревших чанков.
- Два последовательных запуска стартуют с минимальным интервалом во времени.

## Requirements *(mandatory)*

### Functional Requirements

- **FR-001**: Система MUST вычислять hash контента файла с использованием SHA256
  для каждого обрабатываемого файла.
- **FR-002**: Система MUST сохранять hash контента в метаданных индексируемых
  записей.
- **FR-003**: Система MUST проверять наличие уже индексированного hash до upsert
  и пропускать повторную запись неизмененного контента.
- **FR-004**: Система MUST формировать deterministic ID чанка на основе стабильных
  характеристик источника и позиции чанка.
- **FR-005**: Система MUST выполнять upsert по deterministic ID, чтобы повторная
  индексация обновляла существующую запись.
- **FR-006**: Система MUST обновлять записи, если hash контента файла изменился.
- **FR-007**: Система MUST удалять чанки, отсутствующие в актуальной версии файла,
  после завершения обработки измененного файла.
- **FR-008**: Система MUST удалять все связанные чанки из индекса, если исходный
  файл удален из рабочей директории.
- **FR-009**: Система MUST фиксировать в статусе запуска количество обновленных,
  пропущенных и удаленных чанков.
- **FR-010**: Система MUST обеспечивать одинаковый результат индексации при
  повторном запуске на неизмененных данных.
- **FR-011**: Система MUST предоставлять машиночитаемую причину, если запись
  или удаление чанков не выполнены.

### Non-Functional Requirements *(mandatory)*

- **NFR-001**: Повторный запуск индексации на неизмененном наборе данных не должен
  увеличивать количество уникальных записей более чем на 1%.
- **NFR-002**: Для 100% удаленных или обновленных файлов операции синхронизации
  индекса должны быть завершены в том же запуске без ручного вмешательства.
- **NFR-003**: Для 100% ошибок идемпотентной синхронизации должны быть доступны
  классифицированные коды ошибок.

### Assumptions

- Контент файла является источником истины для определения изменений.
- Один запуск индексирует одну рабочую директорию.
- Векторный индекс поддерживает операции upsert и удаление по идентификаторам.

### Key Entities *(include if feature involves data)*

- **FileFingerprint**: путь файла, SHA256 hash, timestamp последней успешной
  индексации.
- **ChunkIdentity**: deterministic ID чанка, ссылка на файл, порядковый номер
  чанка, hash версии файла.
- **ChunkSyncResult**: итог обработки чанка (`updated`, `skipped`, `deleted`,
  `failed`) и код причины.
- **IndexSyncSummary**: агрегированная статистика запуска по обновленным,
  пропущенным, удаленным и ошибочным чанкам.

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: При двух последовательных запусках на неизмененном наборе файлов
  число уникальных записей остается стабильным с отклонением не более 1%.
- **SC-002**: Для не менее 99% измененных файлов обновляются только затронутые
  чанки без появления дубликатов.
- **SC-003**: Для 100% удаленных файлов связанные записи удаляются из индекса в
  рамках того же запуска.
- **SC-004**: Не менее 95% запусков завершаются без ручного восстановления
  консистентности индекса.
- **SC-005**: Для 100% неуспешных операций доступны машиночитаемые коды причин,
  пригодные для автоматической диагностики.
