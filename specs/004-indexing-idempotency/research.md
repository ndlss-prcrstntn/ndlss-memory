# Research: Идемпотентность индексации

## Контекст

Фича: `004-indexing-idempotency`
Цель: гарантировать отсутствие дубликатов при повторной индексации и
детерминированную синхронизацию изменений/удалений файлов в индексе.

## Исследовательские задачи

- Task: "Find best practices for file fingerprinting in incremental indexing"
- Task: "Find deterministic ID patterns for chunked document records"
- Task: "Find safe stale-record cleanup patterns after upsert cycles"
- Task: "Find machine-readable error taxonomy for index sync operations"

## Решения

### Decision: Использовать SHA256 как канонический fingerprint файла
- Rationale: криптографически устойчивый хеш, стабильный для идентичного
  содержимого, доступен в стандартной библиотеке, не требует внешних зависимостей.
- Alternatives considered:
  - MD5: отклонено как более слабый и нежелательный для долгосрочной
    уникальности контента.
  - CRC32: отклонено из-за высокой вероятности коллизий для рабочей нагрузки.

### Decision: Deterministic ID чанка строить из `relativePath + fileHash + chunkIndex`
- Rationale: фиксирует связь чанка с конкретной версией файла и его позицией,
  обеспечивает повторяемость ID между запусками.
- Alternatives considered:
  - Random UUID на каждый запуск: отклонено, ломает идемпотентность и ведет к
    дубликатам.
  - ID только от текста чанка: отклонено, теряется связь с источником и позицией.

### Decision: Перед upsert выполнять проверку существующего fingerprint по файлу
- Rationale: позволяет пропускать неизмененные файлы и снижает ненужные записи
  и вычисления.
- Alternatives considered:
  - Всегда выполнять upsert для всех чанков: отклонено из-за лишней нагрузки и
    роста времени запуска.

### Decision: Устаревшие чанки удалять после расчета нового набора chunk IDs
- Rationale: корректно обрабатывает сокращение контента и удаление файлов,
  сохраняя только актуальное множество записей.
- Alternatives considered:
  - Периодическая фоновая чистка без привязки к запуску: отклонено, не гарантирует
    консистентность в рамках текущего run.

### Decision: Ошибки синхронизации кодировать машиночитаемыми error codes
- Rationale: упрощает автоматическую диагностику и контрактные проверки.
- Alternatives considered:
  - Только текстовые сообщения: отклонено, плохо подходит для автоматизации.

## Outcome

`NEEDS CLARIFICATION` по техническому контексту отсутствуют; все ключевые
решения зафиксированы и пригодны для Phase 1 design.
