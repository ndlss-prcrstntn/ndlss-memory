# Phase 0 Research: Ограничение глубины и объема индексации

## Decision 1: Семантика лимита глубины обхода

- Decision: Глубина считается относительно корня `workspacePath`; корень имеет глубину `0`. При `maxTraversalDepth=0` обрабатываются только файлы верхнего уровня.
- Rationale: Такая модель проста для оператора, однозначна для тестирования и не зависит от внутренней структуры обходчика.
- Alternatives considered:
  - Считать корень как глубину `1`: отклонено, так как вызывает путаницу в граничном случае `0`.
  - Считать глубину по числу разделителей пути без нормализации: отклонено из-за риска несогласованности между платформами.

## Decision 2: Поведение лимита количества файлов

- Decision: `maxFilesPerRun` ограничивает число файлов, допущенных к обработке в рамках одного запуска после базовой фильтрации поддерживаемости/исключений.
- Rationale: Это контролирует фактический объем работы запуска и делает лимит понятным операционно.
- Alternatives considered:
  - Ограничивать число найденных файлов до фильтрации: отклонено, потому что результат зависит от наличия неподдерживаемых файлов и хуже предсказуем.
  - Ограничивать число итоговых чанков вместо файлов: отклонено, так как цель фичи формулируется в файлах и blast radius на уровне файлов.

## Decision 3: Детерминированность отбора при достижении max-files

- Decision: Перед применением `maxFilesPerRun` формируется стабильный порядок кандидатов (нормализованный лексикографический порядок путей).
- Rationale: Повторные запуски с одинаковыми входными данными дают идентичный набор файлов, что покрывает требование детерминизма.
- Alternatives considered:
  - Порядок файловой системы как есть: отклонено из-за недетерминированности между ОС и запусками.
  - Порядок по времени изменения: отклонено из-за нестабильности и скрытой зависимости от внешних процессов.

## Decision 4: Единое применение лимитов в релевантных путях

- Decision: Лимиты применяются в общей точке отбора файлов, используемой `full-scan` и релевантными ingestion-путями, чтобы исключить расхождения.
- Rationale: Единая точка применения уменьшает риск drift между режимами и упрощает тесты регрессии.
- Alternatives considered:
  - Реализовать лимиты отдельно в каждом пути: отклонено, повышает риск несовместимого поведения.

## Decision 5: Формат отчетности по ограничениям

- Decision: В summary добавляются:
  - блок `appliedLimits` с фактическими значениями лимитов;
  - отдельные причины пропуска для depth-limit и file-limit в `skipBreakdown`.
- Rationale: Оператор сразу видит как применялись лимиты и почему файлы не попали в запуск, без чтения сырых логов.
- Alternatives considered:
  - Только агрегированный счетчик "skippedByLimits": отклонено, недостаточно для диагностики.
  - Логировать причины только в runtime-логах: отклонено, не выполняет требование прозрачной summary.

## Decision 6: Backward compatibility дефолтов и валидация

- Decision: Если лимиты не заданы, применяется прежнее поведение без ограничений; невалидные значения отклоняются до начала запуска с явной причиной.
- Rationale: Это сохраняет совместимость текущих сценариев и предотвращает частично некорректные прогоны.
- Alternatives considered:
  - Автоисправление некорректных значений к ближайшему допустимому: отклонено, скрывает ошибки конфигурации.
  - Тихое игнорирование невалидных значений: отклонено, ухудшает наблюдаемость и отладку.
